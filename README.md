<img src="misc/DHR-Health-Logo.png" width="50%">

### **Business Intelligence**

# py835

The **py835** Python package provides a robust toolset for parsing EDI 835 files using the `pyx12` library. It processes healthcare claim information from EDI 835 files into structured formats like Pandas DataFrames and JSON for seamless data manipulation, reporting, and analysis. This allows organizations to quickly extract their data from these files for long-term storage and analysis.

Note that this project is still very much in the early stages. If you require a stable version, please fork this Github repository. We are working on providing a way of translating fields, such as error and reason codes, though that functionality is in the works. 

#### **Table of Contents**
- [py835](#py835)
      - [**Table of Contents**](#table-of-contents)
  - [Features](#features)
  - [Installation](#installation)
    - [Dependencies](#dependencies)
- [Usage](#usage)
- [Pandas Dataframes](#pandas-dataframes)
- [Quick Export](#quick-export)
  - [Contributing](#contributing)
  - [License](#license)

## Features

- **Parse EDI 835 Files:** Load and process `.835` EDI files for healthcare claims and payment information.
- **Extract Data:** Extracts detailed information, including functional groups, transaction sets, claims, services, adjustments, and references.
- **DataFrame Output:** Organizes parsed data into Pandas DataFrames for more convenient analysis.
- **Column Renaming:** Automatically renames columns based on EDI segment codes and descriptions for better readability.
- **Pivot Tables:** Supports pivoting data (e.g., CAS and REF segments) for deeper analysis.
- **JSON Export:** Supports exporting parsed data to JSON format (via pandas) for further use in other systems.


## Installation

To install this package, run the following command:

```bash
pip install git+https://github.com/DHR-Health/py835.git
```

### Dependencies

- `pyx12`: Python library for EDI file parsing.
- `pandas`: Used for organizing parsed data into DataFrames.
- `io`: Standard Python module for handling input/output operations.
- `json`: Used for exporting data to JSON format.

<figcaption><h3>Structure of an 835 file</h3></figcaption>
<img src="misc\835 Structure.png">

# Usage
Parse an 835 file using `py835` to access the data as Pandas dataframes. The parser systematically breaks down the 835 data into hierarchical layers, reflecting the structure of the EDI 835 file. For example, to access statements within the file:



```python
import py835

# Initialize the parser with the path to your EDI file
parser = py835.Parser(r'misc\example.835')
parser.TABLES['STATEMENTS']
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>functional_group_id</th>
      <th>statement_id</th>
      <th>segment</th>
      <th>field</th>
      <th>name</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>ST</td>
      <td>ST01</td>
      <td>Transaction Set Identifier Code</td>
      <td>835</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>ST</td>
      <td>ST02</td>
      <td>Transaction Set Control Number</td>
      <td>35681</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>ST</td>
      <td>ST03</td>
      <td>Implementation Convention Reference</td>
      <td>None</td>
    </tr>
  </tbody>
</table>
</div>



The image below shows the relationships between the tables accessible via `parser.pandas` (if it exists). You can find out which tables are available using the dictionary keys:


```python
[key for key in parser.TABLES]
```




    ['HEADER',
     'FUNCTIONAL_GROUPS',
     'STATEMENTS',
     'STATEMENTS_REF',
     'CLAIMS',
     'SERVICES',
     'SERVICES_CAS',
     'SERVICES_DTM',
     'FOOTER']




<img src="misc\tree_structure.png">

By default, **py835** dataframes are in long-format. The dataframes generated by the package include a custom method for converting these tables to wide format. Use `.flatten` to do so:


```python
parser.TABLES['STATEMENTS_REF'].flatten().head(3)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>functional_group_id</th>
      <th>statement_id</th>
      <th>ref_id</th>
      <th>REFEV REF01</th>
      <th>REFEV REF02</th>
      <th>REFEV REF03</th>
      <th>REFEV REF04</th>
      <th>REFTJ REF01</th>
      <th>REFTJ REF02</th>
      <th>REFTJ REF03</th>
      <th>REFTJ REF04</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>7LtxLY-tBFFEl-J5WaMl-XCVMNS</td>
      <td>EV</td>
      <td>XYZ CLEARINGHOUSE</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>8rZdjF-LxCTjk-rBvam8-x2M4Mp</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>TJ</td>
      <td>212121212</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



You can add descriptions for the fields while flattening the data as well (`descriptions = True`) and add a prefix to the flattened column names (`prefix = <PREFIX>`)


```python
parser.TABLES['STATEMENTS_REF'].head(5).flatten(prefix='My Prefix ',descriptions = True)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>functional_group_id</th>
      <th>statement_id</th>
      <th>ref_id</th>
      <th>My Prefix REFEV REF01 Reference Identification Qualifier</th>
      <th>My Prefix REFEV REF02 Receiver Identifier</th>
      <th>My Prefix REFEV REF03 Description</th>
      <th>My Prefix REFEV REF04 Reference Identifier</th>
      <th>My Prefix REFTJ REF01 Reference Identification Qualifier</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>7LtxLY-tBFFEl-J5WaMl-XCVMNS</td>
      <td>EV</td>
      <td>XYZ CLEARINGHOUSE</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>8rZdjF-LxCTjk-rBvam8-x2M4Mp</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>TJ</td>
    </tr>
  </tbody>
</table>
</div>



You can access individual components of the 835 file using the dictionary at `parser.dict`, if you so desire. The `parser.dict` dictionary contains your 835 data as a JSON:


```python
# Get the STATEMENTS_REF table as a JSON
parser.dict['STATEMENTS_REF']
```




    [{'header_id': 'Ztm36r-NagIgs-GjzfVj-9DczvH',
      'functional_group_id': 'EkT4t7-BYxK1d-5Rlufv-IlvYdZ',
      'statement_id': 'ZKeiG5-YUODH1-aqrfj1-hKwyPb',
      'ref_id': '7LtxLY-tBFFEl-J5WaMl-XCVMNS',
      'segments': [{'segment': 'REFEV',
        'REF01': {'name': 'Reference Identification Qualifier', 'value': 'EV'},
        'REF02': {'name': 'Receiver Identifier', 'value': 'XYZ CLEARINGHOUSE'},
        'REF03': {'name': 'Description', 'value': None},
        'REF04': {'name': 'Reference Identifier', 'value': None}}]},
     {'header_id': 'Ztm36r-NagIgs-GjzfVj-9DczvH',
      'functional_group_id': 'EkT4t7-BYxK1d-5Rlufv-IlvYdZ',
      'statement_id': 'ZKeiG5-YUODH1-aqrfj1-hKwyPb',
      'ref_id': '8rZdjF-LxCTjk-rBvam8-x2M4Mp',
      'segments': [{'segment': 'REFTJ',
        'REF01': {'name': 'Reference Identification Qualifier', 'value': 'TJ'},
        'REF02': {'name': 'Additional Payee Identifier', 'value': '212121212'},
        'REF03': {'name': 'Description', 'value': None},
        'REF04': {'name': 'Reference Identifier', 'value': None}}]}]



# Pandas Dataframes
The **py835** parser generates pandas dataframes from your 835 file so that you can quickly import the data into your data warehouse. These are available using the `parser.TABLES` dictionary. The parser generates ids (`header_id`, `functional_group_id`, `statement_id`, `claim_id`, and `service_id`) as it passes through each component. You can use these IDs when joining the various tables together.

1. **ISA (Interchange Control Header):**  `parser.TABLES['HEADER']`
   The top-level layer is the ISA segment, also called The Header, which contains metadata about the interchange, such as sender/receiver information, control numbers, and transaction timestamps. This segment serves as a unique identifier for the file. You can retrieve the ISA header as a Pandas DataFrame using `parser.pandas['HEADER']`. This allows for easy analysis of interchange metadata, including file-level information.



```python
# Example Header
parser.TABLES['HEADER'].head(5)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>segment</th>
      <th>field</th>
      <th>name</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>ISA</td>
      <td>ISA01</td>
      <td>Authorization Information Qualifier</td>
      <td>00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>ISA</td>
      <td>ISA02</td>
      <td>Authorization Information</td>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>ISA</td>
      <td>ISA03</td>
      <td>Security Information Qualifier</td>
      <td>00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>ISA</td>
      <td>ISA04</td>
      <td>Security Information</td>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>ISA</td>
      <td>ISA05</td>
      <td>Interchange Sender ID Qualifier</td>
      <td>ZZ</td>
    </tr>
  </tbody>
</table>
</div>




1. **Functional Groups (GS):**  `parser.TABLES['FUNCTIONAL_GROUPS']`
   Within each `ISA` segment, there are one or more `GS` (Functional Group Header) segments. Functional groups organize related transaction sets under a specific purpose or business function, such as claims, remittance advice, or payment acknowledgments. You can retrieve information about the functional groups as a Pandas DataFrame using `parser.TABLES['FUNCTIONAL_GROUPS']`. This table can be joined with the ISA table on the `'header_id'` column for comprehensive data analysis across files.



```python
# Example Functional Group
parser.TABLES['FUNCTIONAL_GROUPS'].head(5)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>functional_group_id</th>
      <th>segment</th>
      <th>field</th>
      <th>name</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>GS</td>
      <td>GS01</td>
      <td>Functional Identifier Code</td>
      <td>HP</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>GS</td>
      <td>GS02</td>
      <td>Application Sender's Code</td>
      <td>ABCD</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>GS</td>
      <td>GS03</td>
      <td>Application Receiver's Code</td>
      <td>ABCD</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>GS</td>
      <td>GS04</td>
      <td>Date</td>
      <td>20190827</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>GS</td>
      <td>GS05</td>
      <td>Time</td>
      <td>12345678</td>
    </tr>
  </tbody>
</table>
</div>




1. **Statements (ST):  parser.TABLES['STATEMENTS']**
   Inside each functional group, `ST` segments define statements, also known as transaction sets. Each transaction set corresponds to a statement, bundling related claims, payments, or service details. One 835 file can have multiple transaction sets, which serve as logical groups for payment and claim details. You can extract statement data as a Pandas DataFrame using `parser.TABLES['STATEMENTS']`. This table can be joined with the functional group data using the composite key `['header_id', 'functional_group_id']`.



4. **Claims (CLP):**  `parser.TABLES['CLAIMS']`

   Each transaction set breaks down further into individual claims (`CLP` segments). Claims represent billing information for healthcare services rendered, including important details such as claim IDs, patient identifiers, the total amount billed, adjustments, payments made, and any denials or rejections. You can retrieve claim information as a Pandas DataFrame using `parser.TABLES['CLAIMS']`. Claims can be joined to statement data using the composite key `['header_id', 'functional_group_id', 'statement_id']`.

    4a. **Claim Adjustments (CAS):**  `parser.TABLES['CLAIMS_CAS']`

       Claims often have adjustments (`CAS` segments), which represent reductions or additions to the claim amount based on specific reasons like contractual obligations, patient responsibility, or denials. The parser extracts all adjustments, grouping them by claim, and allows you to retrieve this data in a Pandas DataFrame via `parser.TABLES['CLAIMS_CAS']`.

    4b. **Claim References (REF):**  `parser.TABLES['CLAIMS_REF']`

       The parser captures `REF` (Reference Identification) segments, which contain additional reference information related to claims. These may include provider identification numbers, patient account numbers, or other important reference codes. You can access reference data as a Pandas DataFrame via `parser.TABLES['CLAIMS_REF']`.

    4c. **Claim Service Identification (LQ):**  `parser.TABLES['CLAIMS_LQ']`

       The `LQ` segments provide additional information related to the services or claims, such as service qualifiers and codes. These segments are extracted into a Pandas DataFrame for claims via `parser.TABLES['CLAIMS_LQ']`, which can be joined to the claims table.

    4d. **Claim Date/Time (DTM):**  `parser.TABLES['CLAIMS_DTM']`
    
       The `DTM` segments represent various date and time-related information for claims (e.g., service dates, adjudication dates). You can retrieve claim-related date/time information as a Pandas DataFrame via `parser.TABLES['CLAIMS_DTM']`.


```python
# Example Claim Data
parser.TABLES['CLAIMS'].head(5)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>functional_group_id</th>
      <th>statement_id</th>
      <th>claim_id</th>
      <th>segment</th>
      <th>field</th>
      <th>name</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>CLP</td>
      <td>CLP01</td>
      <td>Patient Control Number</td>
      <td>7722337</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>CLP</td>
      <td>CLP02</td>
      <td>Claim Status Code</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>CLP</td>
      <td>CLP03</td>
      <td>Total Claim Charge Amount</td>
      <td>226</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>CLP</td>
      <td>CLP04</td>
      <td>Claim Payment Amount</td>
      <td>132</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>CLP</td>
      <td>CLP05</td>
      <td>Patient Responsibility Amount</td>
      <td></td>
    </tr>
  </tbody>
</table>
</div>




1. **Service Line Items (SVC):**  `parser.TABLES['SERVICES']`
   
   Within each claim, service line items (`SVC` segments) detail individual healthcare services or procedures performed during the treatment. The line item data includes service codes, charges, allowed amounts, and any related adjustments. You can extract service line data as a Pandas DataFrame using `parser.TABLES['SERVICES']`. These can be linked to the claims table using the composite key `['header_id', 'functional_group_id', 'statement_id', 'claim_id']`.

    5a. **Service Adjustments (CAS):**  `parser.TABLES['SERVICES_CAS']`

       Services often have adjustments (`CAS` segments), which represent reductions or additions to the service amount based on specific reasons like contractual obligations, patient responsibility, or denials. The parser extracts all adjustments, grouping them by service level, and allows you to retrieve this data as a Pandas DataFrame via `parser.TABLES['SERVICES_CAS']`.

    5b. **Service References (REF):**  `parser.TABLES['SERVICES_REF']`

       The parser captures `REF` (Reference Identification) segments for service-level items, which may contain reference information like procedure codes or authorization numbers. These references are extracted into a Pandas DataFrame using `parser.TABLES['SERVICES_REF']`.

    5c. **Service Identification (LQ):**  `parser.TABLES['SERVICES_LQ']`

       Service-level `LQ` segments contain service-specific qualifiers and codes. You can retrieve this information as a Pandas DataFrame via `parser.TABLES['SERVICES_LQ']`.

    5d. **Service Date/Time (DTM):**  `parser.TABLES['SERVICES_DTM']`
    
       The `DTM` segments for services capture date and time-related information (e.g., service dates, procedure dates). This data is available as a Pandas DataFrame using `parser.TABLES['SERVICES_DTM']`.



```python
# Example Service CAS Data
parser.TABLES['SERVICES_CAS'].head(3)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>functional_group_id</th>
      <th>statement_id</th>
      <th>claim_id</th>
      <th>service_id</th>
      <th>cas_id</th>
      <th>segment</th>
      <th>field</th>
      <th>name</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>T1kpbq-2hpgK6-r8osP8-dsaFKh</td>
      <td>L6eo2E-4gT5aE-lN6WMI-6ed9ce</td>
      <td>CASCO</td>
      <td>CAS01</td>
      <td>Claim Adjustment Group Code</td>
      <td>CO</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>T1kpbq-2hpgK6-r8osP8-dsaFKh</td>
      <td>L6eo2E-4gT5aE-lN6WMI-6ed9ce</td>
      <td>CASCO</td>
      <td>CAS02</td>
      <td>Adjustment Reason Code</td>
      <td>45</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ztm36r-NagIgs-GjzfVj-9DczvH</td>
      <td>EkT4t7-BYxK1d-5Rlufv-IlvYdZ</td>
      <td>ZKeiG5-YUODH1-aqrfj1-hKwyPb</td>
      <td>oFoeti-nKFEje-PUFdsp-KqhrcI</td>
      <td>T1kpbq-2hpgK6-r8osP8-dsaFKh</td>
      <td>L6eo2E-4gT5aE-lN6WMI-6ed9ce</td>
      <td>CASCO</td>
      <td>CAS03</td>
      <td>Adjustment Amount</td>
      <td>21</td>
    </tr>
  </tbody>
</table>
</div>




The parser ensures that all segments (ISA, GS, ST, CLP, SVC) are organized in a structured, hierarchical format for easy access and analysis. It also captures important references and adjustments at various levels using `REF` and `CAS` segments, further enhancing the breakdown of claims and services.

# Quick Export
You can use the tables in `parser.pandas` to import the data into your data warehouse for long-term storage, though their long-format structure isn't well-suited for analytics. We've included a way of quickly exporting your data. 



```python
from py835 import Parser

# Initialize the parser with the path to your EDI 835 file
parser = Parser(r'misc\example.835')

bare_bones = parser.flatten(prefix = None,table_names=False,descriptions=False)
bare_bones.head(3)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>ISA ISA01</th>
      <th>ISA ISA02</th>
      <th>ISA ISA03</th>
      <th>ISA ISA04</th>
      <th>ISA ISA05</th>
      <th>ISA ISA06</th>
      <th>ISA ISA07</th>
      <th>ISA ISA08</th>
      <th>ISA ISA09</th>
      <th>...</th>
      <th>CASPR CAS17</th>
      <th>CASPR CAS18</th>
      <th>CASPR CAS19</th>
      <th>dtm_id</th>
      <th>DTM472 DTM01</th>
      <th>DTM472 DTM02</th>
      <th>DTM472 DTM03</th>
      <th>DTM472 DTM04</th>
      <th>DTM472 DTM05</th>
      <th>DTM472 DTM06</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>jsb56Q-donLdj-cK1Pmp-wqQK9q</td>
      <td>00</td>
      <td></td>
      <td>00</td>
      <td></td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>190827</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>tS8WOE-BFF4au-5aKEkv-l9vugN</td>
      <td>472</td>
      <td>20190324</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>1</th>
      <td>jsb56Q-donLdj-cK1Pmp-wqQK9q</td>
      <td>00</td>
      <td></td>
      <td>00</td>
      <td></td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>190827</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>nHMLGm-kBd41W-Xby0I0-5MdnJS</td>
      <td>472</td>
      <td>20190324</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>2</th>
      <td>jsb56Q-donLdj-cK1Pmp-wqQK9q</td>
      <td>00</td>
      <td></td>
      <td>00</td>
      <td></td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>190827</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>37fsYh-BH4xwN-ATHB4D-HbNc3n</td>
      <td>472</td>
      <td>20190324</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
  </tbody>
</table>
<p>3 rows × 122 columns</p>
</div>




Note that the resulting dataframe can have over 200 columns, depending on the amount of data in your 835 file. There are a few customization options available with the `.flatten` method:
    * `prefix (string|None)` - Add a prefix to every column.
    * `table_names (True|False)` - Prepend the name of the table in the column name.
    * `descriptions (True|False)` - Provide descriptions of the fields in the column name.


```python
from py835 import Parser

# Initialize the parser with the path to your EDI 835 file
parser = Parser(r'misc\example.835')

pretty = parser.flatten(prefix = None,table_names=True,descriptions=True)
pretty.head(3)
```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>header_id</th>
      <th>HEADER ISA ISA01 Authorization Information Qualifier</th>
      <th>HEADER ISA ISA02 Authorization Information</th>
      <th>HEADER ISA ISA03 Security Information Qualifier</th>
      <th>HEADER ISA ISA04 Security Information</th>
      <th>HEADER ISA ISA05 Interchange Sender ID Qualifier</th>
      <th>HEADER ISA ISA06 Interchange Sender ID</th>
      <th>HEADER ISA ISA07 Interchange Receiver ID Qualifier</th>
      <th>HEADER ISA ISA08 Interchange Receiver ID</th>
      <th>HEADER ISA ISA09 Interchange Date</th>
      <th>...</th>
      <th>SERVICES_CAS CASPR CAS17 Adjustment Reason Code</th>
      <th>SERVICES_CAS CASPR CAS18 Adjustment Amount</th>
      <th>SERVICES_CAS CASPR CAS19 Adjustment Quantity</th>
      <th>dtm_id</th>
      <th>SERVICES_DTM DTM472 DTM01 Date Time Qualifier</th>
      <th>SERVICES_DTM DTM472 DTM02 Service Date</th>
      <th>SERVICES_DTM DTM472 DTM03 Time</th>
      <th>SERVICES_DTM DTM472 DTM04 Time Code</th>
      <th>SERVICES_DTM DTM472 DTM05 Date Time Period Format Qualifier</th>
      <th>SERVICES_DTM DTM472 DTM06 Date Time Period</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>vWY2tN-9CKVAu-Gzvj0R-T9bbwF</td>
      <td>00</td>
      <td></td>
      <td>00</td>
      <td></td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>190827</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>mowL69-44Ujqa-LIIqAg-dacV2g</td>
      <td>472</td>
      <td>20190324</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>1</th>
      <td>vWY2tN-9CKVAu-Gzvj0R-T9bbwF</td>
      <td>00</td>
      <td></td>
      <td>00</td>
      <td></td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>190827</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>6vnBvw-cZV5vn-2tJIRA-1VCY00</td>
      <td>472</td>
      <td>20190324</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>2</th>
      <td>vWY2tN-9CKVAu-Gzvj0R-T9bbwF</td>
      <td>00</td>
      <td></td>
      <td>00</td>
      <td></td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>ZZ</td>
      <td>ABCPAYER</td>
      <td>190827</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>bejo3q-FBVkxJ-WOM4IJ-GfrMmy</td>
      <td>472</td>
      <td>20190324</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
  </tbody>
</table>
<p>3 rows × 122 columns</p>
</div>





## Contributing

Contributions are welcome! Feel free to submit pull requests or open issues.

1. Fork the repo.
2. Create your feature branch (`git checkout -b feature/my-feature`).
3. Commit your changes (`git commit -am 'Add some feature'`).
4. Push to the branch (`git push origin feature/my-feature`).
5. Open a pull request.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

